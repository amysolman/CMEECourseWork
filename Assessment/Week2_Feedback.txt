Starting weekly assessment for Amy, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 250.86 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, Week5, Week2, Week9, Week4, .git, Miniproject, Week3, Project

Found the following files in parent directory: .gitignore, README.md, .DS_Store

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# CMEE README

My CMEE Coursework Repository

This repository contains the coursework for my CMEE MRes at Imperial College London. The programs therein use shell scripting, python and R. 

Work is divided into week-specified subdirectories (Week1/Week2...) except for where indicated.

Week 1

Practicals using command line and shell scripting only. Sandbox contains practise files. Code contains shell scripts. Data contains data files used with shell scripts. Plus README.md. 

Week 2

Biological computing in Python I. Including: using data structures, writing code, control flow tools, comprehensions, debugging etc.

Week 3

Biological computing in R. Including: Variable types, data structures, manipulating data, control flow tools, vectorisation, data management and visualisation.

Week 4

Statistics in R. Including: Basic statistics for ecology and evolution, with a focus on applicability. Mostly parametric tests (descriptive statistics, t-test, ANOVA, correlations, linear models, hypothesis testing).

Week 5

Spatial Analyses and Geographic Information Systems. Including: GIS data types, obtaining and handling GIS data, creating maps, basic data analyses and hypothesis testing in the spatial domain.

Week 6

Genomics and Bioinformatics. Including: understanding genomic data collection methods, how to choose data collection technique, genomic databases, genetic structure within/between populations, how to characterise and interpret results of common analyses such as STRUCTURE and PCA.

Week 7

Biological Computing in Python II. Including: program testing, debugging and documentation, retrieving, managing and analyzing data from local and remote databases, automate file handling, string manipulation and run shell scripts, efficient numerical analyses, patching together R and Python scripts and functions.

Miniproject (Week 8)

Selected own dataset out of selection of three. Carried out computationally intensive analysis that includes elements of shell scripting, R & Python, addressing questions involving data processing and model fitting, writing up and compiling a meaningful report on the analysis.

Week 9

High Performance Computing. Including: develop an advanced understanding of programming in R, principles of High Performance Computing.

Project

Working folder for dissertation project, including project proposal.


**********************************************************************

======================================================================
Looking for the weekly directories...

Found 8 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7, Week9

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox, Results

Found the following files: README.md, .DS_Store

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# CMEE README WEEK 2

CMEE Bootcamp Week2 (07/10/19-11/10/19)
This week we were introduced to biological computing in Python. We covered topic areas including:
 - Working in ipython
 - Variables
 - Operators
 - Data structures
 - Testing blocks of code
 - Running scripts
 - Control flow tools
 - Comprehensions
 - Writing programs
 - Unit testing/debugging
 - Importing modules

All work was completed used Mac OS Mojave version 10.14.6, Python 3.7.4_1 and the code editor Visual Studio Code. Below is a comprehensive guide to all files and scripts within the WEEK2 directory of my CMEECourseWork folder.

# Sandbox
 - File - test.txt: Simple text file containing lines of text for manipulating in python script basic_io1.py (../Week2/Code).
 - File - testout.txt: Simple text file containing integers 0-99 printed in a column as output from basic_io2.py (../Week2/Code).
 - File - testp.p: File containing pickle dumped dictionary data from basic_io3.py (../Week2/Code)

# Code
  - File - basic_io1.py: Script for opening text file (../Sandbox/test.txt), printing contents of file, closing file, reopening file and printing contents again with the black lines stripped.
  - File - basic_io2.py: Script for saving integers in range 0-100 to new file testout.text.  
  - File - basic_io3.py: Script for pickle dumping (serializing/de-serializing) data from dictionary to testp.p.
  - File - basic_csv.py: Script for taking tabular data and turning into turples within a list. Also creating new csv file with only species name and body mass.
  - File - cfexercises1.py: Script containing six functions. 1) Calculates the square root of a variable. 2) Determines which of two variables is bigger. 3) Re-orders three variables. 4,5 and 6) Three different ways of finding factorials of a variable. Function 5 (foo_5) is a recursive function, calling itself. These foo functions are modules that take arguments from the user.
  - File - loops.py: Script containing fife loops. 1) Prints integers within range(5). 2) Generates and prints a list. 3)Creates list of integers and loops through, adding them to total, printing and generating new total variable. 4) 'While' loop prints variable + 1 and applies output to new variable while variable is < 100. 5) Applies boolean statement to variable and prints message while statement is true.
  - File - cfexercises2.py: Four short scripts combining loops and conditionals. 1) For each value in range(12). When the value divided by 3 has no remainder, print 'hello'. 2) For each value in range(15). When the value is divided by 5 with a remainder of 3 print 'hello', else if the value divided by four has a remainder of 3, print 'hello'. 3) While the value is not equal to 15 print 'hello'. Add three to variable and loop. 4) While the value of the variable is less than 100, if the variable is equal to 31 print 'hello' in range(7). Else if the variable is equal to 18, print 'hello'. Add 1 to variable and loop.
  - File - oaks.py: Four short scripts compairing the creation of sets from previous list/function using for loops and list comprehensions.
  - File - scope.py: Five different scripts showing the effect of global and local variables on output, as well as the 'global' keyword.
  - File - boilerplate.py: Basic "boilerplate" program for using sys module to action function when called in command line.
  - File - using_name.py: Script illustrating the __name__/__main__ code that tells us if a file it being run directly or imported.
  - File - sysargv.py: Script demonstrating the use of sys.argv. Prints name of module, length of module and the arguments applied to it.
  - File - control_flow.py: Five functions exemplifying the use of control statements.
  - File - Ic1.py: Script containing six short modules generated from a set list of birds with latin names, common names and mean body mass. 1) List comprehension containing birds latin names. 2) List comprehension containing birds common names. 3) List comprehension containing birds mean body mass. 4) Conventional loops containing birds latin names. 5) Conventional loops containing birds common names. 4) Conventional loops containing birds mean body mass.
  - File - Ic2.py: Script containing four modules. First two use list comprehension to pull high and low rainfall data. Second two modules serve the same function but using conventional loops.
  - File - dictionary.py: Takes list of tuples including species latin name and order. Converts these to keys (order) and values (species) and prints as dictionary list.
  - File - tuple.py: Takes tuple or tuples (bird species latin, common names and mass) and prints each tuple on a seperate line.
  - File - test_control_flow.py: Script importing doctest module to run test functions on a piece of code.
  - File - debugme.py: Short script with erroneous function for use in debugging.
  - File - align_seqs.py: Takes two DNA sequences from csv file and saves best alignment with corresponding score to seperate txt file (.../Week2/Results/align_seq_result.txt).
  - File - oaks_debugme.py: Oak species search script, bugs removed. Includes doctest.
  - File - align_seqs_fasta.py: Compares DNA sequences of two fasta files.

# Data
 - File - testcsv.csv: Species data taked from TheMulQuaBio's data directory for manipulation in basic_csv.py script (../Week2/Code)
 - File - bodymass.csv: Species name and body mass data file output from basic_csv.py (../Week2/Code)
 - File - TestOaksData.csv: Oaks data for testing script (..Code/oaks_debugme.py)
 - File - 407228326.fasta and 407228326.fasta: Fasta files for use in align_seqs_fasta.py
 - File - align_seqs_data.csv: Seqence data for use in align_seqs.py
 - File - JustOaksData.csv: Output data for oaks_debugme.py **********************************************************************

Found following files in results directory: .gitkeep, align_seq_result.txt, align_seq_result_fasta.txt, .DS_Store...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 22 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, dictionary.py, debugme.py, scope.py, basic_io3.py, cfexercises1.py, tuple.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, basic_io2.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py, basic_io1.py

Found the following extra files: .DS_Store
0.5 pt deducted per extra file

Current Points = 99.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

__appname__ = 'Ic2.py'
__version__ = '0.0.1'

"""In shell either run lc2.py (for ipython)
or python3 lc2.py. Script contains four modules. First two use list
comprehension to pull high and low rainfall data.
Second two modules serve the same function but using conventional loops.""" 

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

high_rainfall = [r for r in rainfall if r[1] > 100.0]
print(high_rainfall)
 
# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

low_rainfall = [m[0] for m in rainfall if m[1] < 50.0]
print(low_rainfall)

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

high_rainfall = []
for row in rainfall:
    if row[1] > 100.0:
        high_rainfall.append(row)

print(high_rainfall)

low_rainfall = []
for row in rainfall:
    if row[1] < 50.0:
        low_rainfall.append(row[0])
        
print(low_rainfall)**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']

**********************************************************************

Code ran without errors

Time consumed = 0.05603s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 - specifies location to python
# Tells the computer where to look for python
# Determines scripts ability to execute when part of a program

# Triple quotes start 'docstring' comment, describes operation of the script
# OR function/module within it
# Part of the running code in contrast to normal comments
# Access docstrings at run time
# Put at start
"""Description of this program or application.
    You can use several lines"""
# __ signal "internal" variables. Special variable names reserved
# By python for its own purposes

__appname__='[application name here]'
__author__= 'Your Name (your@email.address)'
__version__= '0.0.1'
__license__= "License for this code/program"


## imports ##
import sys # module to interface our program with the operating system
# allows you to be able to access modules from this program elsewhere using the module name

## constants ##

## functions ##
# def indicates start of a python function, all subsequent lines must be indented
# File containing function def and statements (assignments of constant variables) called modules
# argv = argument variable. A variable that holds the arguments you pass 
# to your Python script when you run it
# sys.argv object created by python using sys module (imported at beginning of script)
# that contains names of the argument variables in the current script

# This is the main function. Arguments obtained in the __name__ function
# Are fed to the main function
# if main function called only code in this module imported into other programs
# argv means arguments (values passed to a function) vector (transporter)
def main(argv): # defining main as a function and 
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented used two tabs or 4 spaces
    return 0 # 0 means everything ran and has been fine. Hidden variable.

# Makes the file useable as a script as well as an importable moduel
# Directs python to set the special name variable (__name__) to have the value "__main__"
# This part means if you type the function name into command line
# it will action the module
if __name__ == "__main__":
    """Makes sure the "main" function is called from the command line"""
    status = main(sys.argv)
    sys.exit(status)
# Terminates the program in an explicit manner, returning appropriate status code
# Main () returns 0 on successful run
# sys.exit(status) returns zero - successful termination

**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.03530s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

__appname__ = 'basic_csv.py'
__version__ = '0.0.1'

"""Reads tabular file with species name, order, family, 
distribution and male body mass. Read in to csvread variable,
for each row of information transforms into turples within temp list.
Prints 'The species is' followed by each turpled row."""

import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
f = open('../data/testcsv.csv','r')

csvread = csv.reader(f) # reads in the info using csv module and saves to csvread variable
temp = [ ] #create an empty list
for row in csvread: #for each row in the data read from the file
    temp.append(tuple(row)) #add to the list 'temp' the row data as a tuple
#Tuples are like a list but immutable, that is, a particular pair or sequence of strings
#or numbers cannot be modified after it is created
#So a tuple is like a read-only list

print(row)
print("The species is", row[0])

# Includes top info in table (species, infraorder etc.)

f.close()

# With is a better manner to handle file open/close operations
# with open('../Data/testcsv.csv', 'r') as f:
#     csvread = csv.reader(f)
#     temp = []
#     for row in csvread:
#         temp.append(tuple(row))
#     print(row)
#     print("The species is", row[0])


# write a file containing only species name and Body mass
f = open('../data/testcsv.csv','r') #open the data file
g = open('../data/bodymass.csv','w') #create/open a new file we're going to put our data into

csvread = csv.reader(f) #create a new vector with the data from the file
csvwrite = csv.writer(g) #create a new vector to fill with the data for our new file
for row in csvread: #for each row in the data
    print(row) #print the row
    csvwrite.writerow([row[0], row[4]]) #write to our new file the data from the first row and 5th column

f.close()
g.close()

**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_csv.py", line 15, in <module>
    f = open('../data/testcsv.csv','r')
FileNotFoundError: [Errno 2] No such file or directory: '../data/testcsv.csv'

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

__appname__ = 'cfexercises2.py'
__version__ = '0.0.1'

"""In shell either run cfexercises2.py (for ipython)
or python3 cfexercises2.py. Script contains four scripts
combining loops and conditionals.""" 

# Prints 'hello' each time a number (in range 12) divided by 3 has no remainder
for j in range(12):
    if j % 3 == 0:
        print('hello')

# Prints 'hello' each time a number (in range 15) divided by 5 has a remainder of 3 OR divided by 4 has a remainder of 3
for j in range(15):
    if j % 5 == 3:
        print('hello')
    elif j % 4 == 3:
        print('hello')

# Prints 'hello' each time z isn't equal to 0, then adds 3 to z and repeats
z = 0
while z != 15:
    print('hello')
    z = z + 3

# Prints 'hello' 7 times when z is equal to 31 and one when equal to 18, then stops at 100
z = 12
while z < 100:
    if z == 31:
        for k in range(7):
            print('hello')
    elif z == 18:
        print('hello')
    z = z + 1**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.02601s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

__appname__ = 'dictionary.py'
__version__ = '0.0.1'

"""In shell either run dictionary.py (for ipython)
or python3 dictionary.py. Script will populate a dictionary dervied from taxa,
so that order names are mapped to taxa.""" 

taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 

taxa_dic = dict()

for s in taxa:
    if s[1] in taxa_dic:
        taxa_dic[s[1]].append(s[0])
    else:
        taxa_dic[s[1]] = [s[0]]
print(taxa_dic)

**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
{'Chiroptera': ['Myotis lucifugus'], 'Carnivora': ['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus'], 'Afrosoricida': ['Microgale dobsoni', 'Microgale talazaci'], 'Rodentia': ['Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomys rutilus']}

**********************************************************************

Code ran without errors

Time consumed = 0.03001s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
#!/urs/bin/env python3
# Date: Oct 2019

"""Short script for running with python debugger"""

def makeabug(x):
    y = x**4 # x to the power of 4
    z = 0.
    y = y/z # doesn't work because you can't divide by 0
    return y

makeabug(25)

**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 99.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "debugme.py", line 12, in <module>
    makeabug(25)
  File "debugme.py", line 9, in makeabug
    y = y/z # doesn't work because you can't divide by 0
ZeroDivisionError: float division by zero

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

__appname__ = 'oaks.py'
__version__ = '0.0.1'

"""In shell either run scope.py (for ipython)
or python3 scope.py. Script will generate five short scripts
looking at the value of local and global variables."""

# Functions are blocks of code that only run when called.
# What is created inside a function stays inside a function.
# Variables inside a function are invisible outside of it
# They don't presist once a function is run - these are local variables!
# Global variables are visible inside and outside functions
# Any variable created OUTSIDE the function is GLOBAL
# To create a GLOBAL variable inside a function use the GLOBAL keyword

_a_global = 10 # a global variable with value 10

if _a_global > 5: # if _a_global variable is greater than 5
    _b_global = _a_global + 5 # _b_global variable is equal to _a_global variable plus 5

def a_function(): # Let's (def)ine a function!
    _a_global = 5 # a local variable because it's inside a function

    if _a_global >= 5: # if this local variable is greater than or equal to 5
        _b_global = _a_global + 5 # we create _b_global which takes on the value of _a_global plus 5

    _a_local = 4 # This is a new local variable with the value 4

    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value of _b_global is ", _b_global)
    print("Inside the function, the value of _a_local is ", _a_local)

    return None # Don't tell me anything else about this function - Just STOP!

a_function()

print("Outside the function the value of _a_global is ", _a_global)
print("Outside the function, the value of _b_global is ", _b_global)

_a_global = 10

def a_function():
    _a_local = 4

    print("Inside the function, the value _a_local is ", _a_local)
    print("Inside the function, the value of _a_global is ", _a_global)

    return None

a_function()

print("Outisde the function, the value of _a_global is ", _a_global)

_a_global = 10

print("Outside the function, the value of _a_global is ", _a_global)

def a_function():
    global _a_global
    _a_global = 5
    _a_local = 4

    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value of _a_local is ", _a_local)

    return None

a_function()

print("Outside the function, the value of _a_global now is", _a_global)

def a_function():
    _a_global = 10

    def _a_function2():
        global _a_global
        _a_global = 20

    print("Before calling a_function, value of _a_global is ", _a_global)

    _a_function2()

    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of _a_global in main workspace / namespace is ", _a_global)

_a_global = 10

def a_function():

    def _a_function2():
        global _a_global
        _a_global = 20

    print("Before calling a_function, value of _a_global is ", _a_global)

    _a_function2()

    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of _a_global in main workspace / namespace is ", _a_global)
**********************************************************************

Testing scope.py...

scope.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value of _a_global is  5
Inside the function, the value of _b_global is  10
Inside the function, the value of _a_local is  4
Outside the function the value of _a_global is  10
Outside the function, the value of _b_global is  15
Inside the function, the value _a_local is  4
Inside the function, the value of _a_global is  10
Outisde the function, the value of _a_global is  10
Outside the function, the value of _a_global is  10
Inside the function, the value of _a_global is 
**********************************************************************

Code ran without errors

Time consumed = 0.02507s

======================================================================
Inspecting script file basic_io3.py...

File contents are:
**********************************************************************
##!/usr/bin/env python3

#############################
# STORING OBJECTS
#############################

__appname__ = 'basic_io3.py'
__version__ = '0.0.1'

""" In shell either run basic_io3.py (for ipython)
or python3 basic_io3.py. Script will create a dictionary and
save it to testp.p then load the data again and save to another_dictionary
then print. """

# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

# pickle module implements binary protocols for serializing/
# de-serializing an object structure. 
# Converts an object in memory to a byte stream than can be stored or sent over network.
import pickle

f = open('../sandbox/testp.p', 'wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f) #put the binary version of my dictionary into the file
f.close()

## Load the data again
f = open('../sandbox/testp.p', 'rb')
another_dictionary = pickle.load(f) #load the binary data from the file into another_dictionary
f.close()

print(another_dictionary)**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io3.py", line 23, in <module>
    f = open('../sandbox/testp.p', 'wb') ## note the b: accept binary files
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testp.p'

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

__appname__ = 'cfexercises1.py'
__version__ = '0.0.1'

"""In shell either run cfexercises1.py (for ipython)
or python3 cfexercises1.py. Script will generate several different functions
using different conditionals. Sys module means functions can be called 
for use with other scripts.""" 

import sys 

# What does each of foo_x do?
# This take the square root
def foo_1(x=4):
    return x ** 0.5 

# Takes two numbers, prints the largest
def foo_2(x=5, y=10):
    if x > y:
        return x
    if x < y:
        return y


# Tries to sort numerically but doesn't fully work
def foo_3(x=5, y=2, z=3):
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return [x, y, z]

 #Here is an alterntaive script that sorts three integers
def foo_3a(x=8, y=4, z=6):
    a = min(x, y, z)
    b = max(x, y, z)
    c = (x + y + z) - (a + b)
    return [a, c, b]

# Factoria of 4 = (4x1) + (4x2) + (4x3) = 24
def foo_4(x=4):
    """ Calculate the factorial of x """
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result

def foo_5(x=24): # a recursive function (calls itself - foo_5) that calculates the factorial of x
    if x == 1:
        return 1
    return x * foo_5(x - 1)

def foo_6(x=4): # Calculate the factorial of x in a different way
    facto = 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto 

def main(argv):
    print(foo_1(4))
    print(foo_2(5, 10))
    print(foo_3(5, 2, 3))
    print(foo_3a(8, 4, 6))
    print(foo_4(4))
    print(foo_5(24))
    print(foo_6(4))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
    
**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 92.0

Output (only first 500 characters): 

**********************************************************************
2.0
10
[2, 3, 5]
[4, 6, 8]
24
620448401733239439360000
24

**********************************************************************

Code ran without errors

Time consumed = 0.02656s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

__appname__ = 'tuple.py'
__version__ = '0.0.1'

"""In shell either run tuple.py (for ipython)
or python3 tuple.py. Script prints bird data on seperate lines by species.""" 

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# Hints: use the "print" command! You can use list comprehensions!

for s in birds:
    print (s[0], s[1], s[2])**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 92.0

Output (only first 500 characters): 

**********************************************************************
Passerculus sandwichensis Savannah sparrow 18.7
Delichon urbica House martin 19
Junco phaeonotus Yellow-eyed junco 19.5
Junco hyemalis Dark-eyed junco 19.6
Tachycineata bicolor Tree swallow 20.2

**********************************************************************

Code ran without errors

Time consumed = 0.02950s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

__appname__ = 'Ic1.py'
__version__ = '0.0.1'

"""In shell either run lc1.py (for ipython)
or python3 lc1.py. Script will contains six modules creating different
lists from the bird data provided. Created using list comprehension and
loops.""" 

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

# List comprehension containing birds latin names

birds_latin = {b[0] for b in birds}
print(birds_latin)

# List comprehension containing birds common names

birds_common = {b[1] for b in birds}
print(birds_common)

# List comprehension containing mean body masses

birds_bodymass = {b[2] for b in birds}
print(birds_bodymass)


# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

# Conventional loop printing birds latin names

birds_latin = []
for b in birds:
    birds_latin.append(b[0])
print(birds_latin)

# Conventional loop printing birds common names

birds_common = []
for b in birds:
    birds_common.append(b[1])
print(birds_common)

# Conventional loop printing birds mean body mass

birds_bodymass = []
for b in birds:
    birds_bodymass.append(b[2])
print(birds_bodymass)**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 92.0

Output (only first 500 characters): 

**********************************************************************
{'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor', 'Passerculus sandwichensis', 'Delichon urbica'}
{'Savannah sparrow', 'Dark-eyed junco', 'Tree swallow', 'Yellow-eyed junco', 'House martin'}
{19.5, 19.6, 18.7, 19, 20.2}
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.03299s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 

"""Script reading tree species from a file and adding to
second file if oak species. Includes doctest."""

# Open and run the code oaks_debugme.py — there's a bug, for no oaks are being found! 
# (where's TestOaksData.csv? — in the data directory of TheMulQuaBio repo!)
# Fix the bug (e.g., you could insert a debugging breakpoint using import ipdb; ipdb.set_trace())
# Now, write doctests to make sure that, bug or no bug, your is_an_oak function is working as expected 
# (hint: >>> is_an_oak('Fagus sylvatica') should return False)
# If you wrote good doctests, you will find another bug that you might not have by just debugging 
# (hint: what happens if you try the doctest with "Quercuss" instead of "Quercus"? Should this pass or fail?). 
# Modify your doctests approriately, and modify your script such that it can handle cases where there is a typo 
# (such as 'Quercuss') or there is a genus name that is not strictly 'Quercus'. 

__appname__ = 'oaks_debugme.py'

__version__ = '0.0.1'


import csv # to read and write csvs
import sys # to modularise functions within a script
# can be used to get information from the user
# part of the standard library within python - does lots of things!
import doctest # to test arguments against a function


def is_an_oak(name): # define a function
    """ Returns True if name is starts with 'quercus'
    Find whether a species is an oak or not.
    doctest
    >>> is_an_oak('Fraxinus excelsior')
    False
    
    >>> is_an_oak('Pinus sylvestris')
    False
    
    >>> is_an_oak('Quercus petraea')
    True

    """
    return name.split()[0].lower() == 'quercus' # give me the variable in lowercase if it starts with 'quercs'



def main(argv): # define's the main function that will take the argument value (argv)
# argv is a list - first value is name of the value. Shows where you are in the file system
    f = open('../data/TestOaksData.csv','r') # open testoaksdata to read
    g = open('../data/JustOaksData.csv','w') # open a new file  justoaksdata to write
    writer = csv.DictWriter(
        g, fieldnames=["Genus", "Species"])
    writer.writeheader()
    taxa = csv.reader(f) # the variable (taxa) is applied to the testoaksdata file
    csvwrite = csv.writer(g) # the variable (csvwrite) is applied to the justoaksdata file
    next(taxa, None)
    oaks = set() # create a new set called oaks
    
    for row in taxa: # for each thing in testoaksdata
        print(row) # print that thing
        print ("The genus is: ") # print 'the genus is'
        print(row[0] + '\n') # print the first character in the first row of things in the testoaks data with a break
        if is_an_oak(row[0]): 
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])  
    

    return 0

doctest.testmod()

    
if (__name__ == "__main__"):
    status = main(sys.argv)**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 91.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "oaks_debugme.py", line 73, in <module>
    status = main(sys.argv)
  File "oaks_debugme.py", line 48, in main
    f = open('../data/TestOaksData.csv','r') # open testoaksdata to read
FileNotFoundError: [Errno 2] No such file or directory: '../data/TestOaksData.csv'

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

__appname__ = 'oaks.py'
__version__ = '0.0.1'

"""In shell either run oaks.py (for ipython)
or python3 oaks.py. Script will generate a function for finding oaks within a list,
adds those species to a new set using loops, does the same again using list comprehensions.
The script then runs the same modules again with UPPER CASE outputs.""" 

## Finds just those taxa that are oak trees from a list of species
# Adds any species from the list that match the defined criteria
taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea'
        ]
def is_an_oak(name): # define a function (is_an_oak) to be used with variable (name)
    return name.lower().startswith('quercus ') # give the variable (name) is lowercase if it
# starts with string 'quercus'. This does not print the list just applied them to the is_an_oak
# function.

## Using for loops
# From the pre-defined list is_an_oak, adds those species to a seperate set oaks_loops
oaks_loops = set() # create a new empty set (oak_loops)
for species in taxa: # for items (species) in the list (taxa)
    if is_an_oak(species): # if an item (species) matches with names added to the previous function
        oaks_loops.add(species) # add that item to the function
print(oaks_loops) # print the function

## Using list comprehensions
# Adds species from is_an_oak species to oaks_lc list
oaks_lc = set([species for species in taxa if is_an_oak(species)]) # creates new set
# conditional says if there is an item in the taxa list that matches the is_an_oak list 
# it will be added to the new list
print(oaks_lc) # print the list

## Get names in UPPER CASE using for loops
oaks_loops = set() # create empty set
for species in taxa: # for items in original list
    if is_an_oak(species): # if they match items in the is_an_oak function
        oaks_loops.add(species.upper()) # add them to oaks_loops in upper case
print(oaks_loops) # print list

## Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)]) # create new set 
# items printed in uppercase for items in list if same at items in function
print(oaks_lc) # print list**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 91.0

Output (only first 500 characters): 

**********************************************************************
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'QUERCUS PETRAEA', 'QUERCUS CERRIS', 'QUERCUS ROBUR'}
{'QUERCUS PETRAEA', 'QUERCUS CERRIS', 'QUERCUS ROBUR'}

**********************************************************************

Code ran without errors

Time consumed = 0.02610s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

__appname__ = 'loops.py'
__version__ = '0.0.1'

"""In shell either run loops.py (for ipython)
or python3 loops.py. Script contains five loops.
First loop will print integers within range(5). 
Second generates and print a list. Third creates list of
integers and loops through, adding them to total, printing and generating 
new total variable. Fourth 'while' loop prints variable + 1 and applies
output to new variable while variable is < 100. Fifth applies boolean statement 
to variable and prints message while statement is true.""" 

# FOR loops in Python
# Prints all numbers up to range (5)
for i in range(5): 
    print(i)

# Prints list
my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

# Prints accending numbers 0, 1, 12, 123, 1234
total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
print(total)

# WHILE loops in Python
# Prints numbers 1 to 100
z = 0
while z < 100:
    z = z + 1
print(z)

# Prints infinite loop of string
b = True
while b:
    print("GERONIMO! infinite loop! ctrl+c to stop!")
# ctrl + c to stop!**********************************************************************

Testing loops.py...

loops.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 91.0

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
1234
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GE
**********************************************************************

Code ran without errors

Time consumed = 10.32885s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019
# Filename: using_name.py

"""In shell either run using_name.py (for ipython)
or python3 using_name.py. Script will generate several different functions
using different conditionals.""" 

# Before python runs the code in a file it sets a few special variables, 
# __name__ is one of them. When it runs the file directly it sets the __name__ variable
# equal to __main__. But we can also import modules! Whenever we import a module 
# from another program/module, it sets the __name__ variable to the name of the file. 
# In this case __using_name__. It does this because the module is no longer being run directly
# from Python, it is being imported. This is useful because we can check if the file
# is being run directly from Python or imported.

if __name__ == '__main__':
    print('This program is being run by itself') # This program is being run directly!
else:
    print('I am being imported from another module')

print("This module's name is: " + __name__)

**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 91.0

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself
This module's name is: __main__

**********************************************************************

Code ran without errors

Time consumed = 0.06427s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

"""Script to take two DNA sequences from csv file, align, score and output to txt file"""

__appname__ = 'align_seqs.py'
__author__ = 'Amy Solman (amy.solman19@imperial.ac.uk)'
__version__ = '0.0.1'

import csv

f = open('../Data/align_seq_data.csv', 'r')

csvread = csv.reader(f)
seq2 = ""
seq1 = ""
for row in csvread:
    seq2 = (row[0])
    seq1 = (row[1])

l1 = len(seq1) # l1 variable is assigned the length of sequence 1
l2 = len(seq2) # l2 variable is assigned the length of sequence 2
if l1 >= l2: # if l1 is greater than or equal to l2
    s1 = seq1 # assign the longest variable (s1) to sequence 1
    s2 = seq2 # assign the shorted variable (s2) to sequence 2
else:
    s1 = seq2 # assign the longest variable (s1) to sequence 2
    s2 = seq1 # assign the shorted variable (s2) to sequence 1
    l1, l2 = l2, l1 # swap the two length values
#seq1 was linked to l1, seq2 was linked to l2.
#if length of seq1 >= seq2 then seq1 string applied to s1
#if length of seq1 >= seq2 then seq2 string applied to s2
#if length of seq1 < seq2 then seq1 string applied to s2 and l1 takes on length of l2
#if length of seq1 < seq2 then seq2 string applied to s1 and l2 takes on length of l1

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint): 
    matched = "" # to hold string displaying alignements
    score = 0 # set score value to 0
    for i in range(l2): # for item in the range of 0 to length2 (shorter length)
        if (i + startpoint) < l1: 
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
print(my_best_align)
print(s1)
print("Best score:", my_best_score)

f = open('../Results/align_seq_result.txt', 'w')
f.write(str(my_best_align) + "\n" + str(s1) + "\n" + str(my_best_score))


f.close()
**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 90.5

Output (only first 500 characters): 

**********************************************************************
------*****
 CAATTCGGAT
﻿ATCGCCGGATTACGGG
5
 
.-------*--*
. CAATTCGGAT
﻿ATCGCCGGATTACGGG
2
 
..-*---------
.. CAATTCGGAT
﻿ATCGCCGGATTACGGG
1
 
...---------*-
... CAATTCGGAT
﻿ATCGCCGGATTACGGG
1
 
....-*---------
.... CAATTCGGAT
﻿ATCGCCGGATTACGGG
1
 
.....-*---*-----
..... CAATTCGGAT
﻿ATCGCCGGATTACGGG
2
 
......---***--*--
...... CAATTCGGAT
﻿ATCGCCGGATTACGGG
4
 
.......--*-*-***-
....... CAATTCGGAT
﻿ATCGCCGGATTACGGG
5
 
........-------**
........ CAATTCGGAT
﻿ATCGCCGGATTACGGG
2
 
.........---*---*

**********************************************************************

Code ran without errors

Time consumed = 0.05194s

======================================================================
Inspecting script file basic_io2.py...

File contents are:
**********************************************************************
##!/usr/bin/env python3

#############################
# FILE OUTPUT
#############################

""" In shell either run basic_io2.py (for ipython)
or python3 basic_io2.py and the module will save the numbers 0-99
to a new file called testout.txt. """

__appname__ = 'basic_io2.py'
__version__ = '0.0.1'

# Save the elements of a list to a file
list_to_save = range(100) #remember this starts at 0

f = open('../Sandbox/testout.txt', 'w') # w means write
for i in list_to_save: #for each item in the vector (0-99)
    f.write(str(i) + '\n') #Add a new line at the end

f.close()**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 90.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.02604s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

__appname__ = 'sysargv.py'
__version__ = '0.0.1'

"""In shell either run sysargv.py (for ipython)
or python3 sysargv.py. Script will generate the name of the module,
number of arguments applied to the module, and a list of the arguments.""" 

# An argument is a value provided to a function when you call it
import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: ", str(sys.argv))**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 90.5

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.02719s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

"""Script to take two DNA sequences from fasta files, align, score and output to txt file"""

__appname__ = 'align_seqs_fasta.py'
__author__ = 'Amy Solman (amy.solman19@imperial.ac.uk)'
__version__ = '0.0.1'

import csv
import sys

def fasta_align(x, y):
    for input in x, y:
        with open(input, 'r') as afile:
            read_data = afile.read()

x = open('../Data/407228326.fasta', 'r')
y = open('../Data/407228412.fasta', 'r')


csvread1 = csv.reader(x)
csvread2 = csv.reader(y)
seq1 = ""
seq2 = ""
for row in csvread1:
    seq1 = (row[0])
for row in csvread2:
    seq2 = (row[0])

l1 = len(seq1) # l1 variable is assigned the length of sequence 1
l2 = len(seq2) # l2 variable is assigned the length of sequence 2
if l1 >= l2: # if l1 is greater than or equal to l2
    s1 = seq1 # assign the longest variable (s1) to sequence 1
    s2 = seq2 # assign the shorted variable (s2) to sequence 2
else:
    s1 = seq2 # assign the longest variable (s1) to sequence 2
    s2 = seq1 # assign the shorted variable (s2) to sequence 1
    l1, l2 = l2, l1 # swap the two length values
#seq1 was linked to l1, seq2 was linked to l2.
#if length of seq1 >= seq2 then seq1 string applied to s1
#if length of seq1 >= seq2 then seq2 string applied to s2
#if length of seq1 < seq2 then seq1 string applied to s2 and l1 takes on length of l2
#if length of seq1 < seq2 then seq2 string applied to s1 and l2 takes on length of l1

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint): 
    matched = "" # to hold string displaying alignements
    score = 0 # set score value to 0
    for i in range(l2): # for item in the range of 0 to length2 (shorter length)
        if (i + startpoint) < l1: 
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
print(my_best_align)
print(s1)
print("Best score:", my_best_score)

f = open('../Results/align_seq_result_fasta.txt', 'w')
f.write(str(my_best_align) + "\n" + str(s1) + "\n" + str(my_best_score))

f.close()

def main(argv):
    print(fasta_align('../Data/407228326.fasta', '../Data/407228412.fasta'))

if __name__ == '__main__':
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 89.0

Output (only first 500 characters): 

**********************************************************************
-*-*--**---*----
TCTTTTTTTTTTTTTT
ACCTGGTTCCATGAAGACCCTGCCCCTCA
5
 
.-**--**---*-----
.TCTTTTTTTTTTTTTT
ACCTGGTTCCATGAAGACCCTGCCCCTCA
5
 
..----**---*------
..TCTTTTTTTTTTTTTT
ACCTGGTTCCATGAAGACCCTGCCCCTCA
3
 
...*--**---*-------
...TCTTTTTTTTTTTTTT
ACCTGGTTCCATGAAGACCCTGCCCCTCA
4
 
....--**---*--------
....TCTTTTTTTTTTTTTT
ACCTGGTTCCATGAAGACCCTGCCCCTCA
3
 
.....--*---*--------*
.....TCTTTTTTTTTTTTTT
ACCTGGTTCCATGAAGACCCTGCCCCTCA
3
 
......*----*--------*-
......TCTTTTTTTTTTTTTT
ACCTGGTTCCATGAAGA
**********************************************************************

Code ran without errors

Time consumed = 0.03344s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

"""Some functions exemplifying the use of control statements"""
#docstrings are considered part of the running code (normal comments
# are stripped). Hence, you can access your docstrings at run time.

__appname__ = 'countrol_flow.py'
__author__ = 'Samraat Pawar (s.pawar@imperial.ac.uk)'
__version__ = '0.0.1'

import sys # module to interface our program with the operating system

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x % 2 == 0: # If the variable / 2 has remainder 0
        return "%d is Even!" % x # Give me 'variable' is Even
    return "%d is Odd!" % x # Remainder != 0 give me 'variable' is Odd
def largest_divisor_five(x=120): # Define function, 0 = 120 if not specified
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0 # variable (largest) = 0
    if x % 5 == 0: # if variable (x) / 5 has remainder 0
        largest = 5 
    elif x % 4 == 0: # means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest == 2
    else: # When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable.
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): # "range" returns a sequence of integers
        if x % i == 0:
            print("%d is not a prime: %d is a divisor" % (x, i))
            return False

    print("%d is a prime!" % x)
    return True

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

# Makes the file useable as a script as well as an importable moduel
# Directs python to set the special name variable (__name__) to have the value "__main__"
if __name__ == "__main__":
    """Makes sure the "main" function is called from the command line"""
    status = main(sys.argv)
    sys.exit(status)
# Terminates the program in an explicit manner, returning appropriate status code
# Main () returns 0 on successful run
# sys.exit(status) returns zero - successful termination

**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 89.0

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.03251s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2019

"""Some functions exemplifying the use of control statements"""

__author__ = 'Amy Solman (amy.solman19@imperial.ac.uk'
__version__ = '0.0.1'

import sys
import doctest # Import the doctest module

def even_or_odd(x=0): 
    """Find whether a number x is even or odd.

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided, then the closest integer is used:
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken:
    >>> even_or_odd(-2)
    '-2 is Even!'

    """
    # Define function to be tested
    if x % 2 == 0: 
        return "%d is Even!" % x
    return "%d is Odd!" % x

####### I SUPPRESSED THIS BLOCK: WHY? #######
# This would print out test arguments which we don't need because we're already using doctest
#def main(argv):
#    print(even_or_odd(22))
#    print(even_or_odd(33))
#    print(largest_divisor_five(120))
#    print(largest_divisor_five(121))
#    print(is_prime(60))
#    print(is_prime(59))
#    print(find_all_primes(100))
#    return 0

#if __name__ == "__main__":
#    """Makes sure the "main" function is called from the command line"""
#    status = main(sys.argv)
################################################

doctest.testmod() # To run with embedded tests

**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 89.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.06444s

======================================================================
Inspecting script file basic_io1.py...

File contents are:
**********************************************************************
##!/usr/bin/env python3

#############################
# FILE INPUT
#############################

""" In shell either run basic_io1.py (for ipython)
or python3 basic_io1.py and the test file will print
to terminal. """

__appname__ = 'basic_io1.py'
__version__ = '0.0.1'

# Open a file for reading
f = open('../sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f: #for each line in file
    print(line) #print the line

# close the file
f.close()

""" Second module prints contents of file as before
but with lines removed. """

# Same example, skip blank lines
f = open('../sandbox/test.txt', 'r') # r for read
for line in f: #for each line in the file
    if len(line.strip()) > 0: #if the number of characters in the line (after removing trailing characters) is greater than zero
        print(line) #print the line

f.close()**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 87.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io1.py", line 15, in <module>
    f = open('../sandbox/test.txt', 'r')
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/test.txt'

======================================================================
======================================================================
Finished running scripts

Ran into 5 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 87.0

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!