source('~/Documents/CMEECourseWork/Week6/Code/Genom4.R')
source('~/Documents/CMEECourseWork/Week6/Code/Genom3.R')
source('~/Documents/CMEECourseWork/Week6/Code/Genom2.R')
sites_total <- 0 #set the number of total sites (columns) to 0
sites_divergent <-  0 #set the numnber of divergent sites (columns) to 0
#We need to remove the SNPs within each species - what does this mean?
#SNPs are single nucleotide polymorphisms or 'snips'. These are where alleles in
#diploid individuals are not the same, so instead of CC, AA, TT, having a pair of matching
#nucleotides, they have polymorphic nucleotides CA or TG etc. These are NOT fixed
#within the population, they are individual mutations that will not help us
#understand how similar whole species are. We want to look exclusively at the genetic
#information that it fixed within each species to draw a useful comparison.
#So let's remove the columns of data that do not have matching alleles for that
#individual.
for (i in 1:ncol(WestBand)) { #for each column of values (alleles) in WestBand
if
(length(unique(WestBand[,i]))==1 & #if the number (length) of unique values in the column of the first species equals 1 and
length(unique(BentToed[,i]))==1) {#the number (length) of unique values in the column of the second species equals 1
sites_total <- sites_total + 1 # adds up the number of non-SNP sites for both species
#if different, then it's a divergent site
if
(WestBand[1,i] != BentToed[1,i]) # if the first row and any columns of species one and different from species two
sites_divergent <- sites_divergent + 1 # adds up the number of sites that are different between the two species
}
}
#So if we have the locations of the non-SNP data for both species, and the places that they are different
#we can calculate the divergence rate
divergence_rate_WB_BT <- sites_divergent / sites_total
print(divergence_rate_WB_BT) #0.0037
#Now we'll repeat this for each pair - WestBand and Leopard
sites_total <- 0
sites_divergent <- 0
for (i in 1:ncol(WestBand)) {
if
(length(unique(WestBand[,i]))==1 &
length(unique(Leopard[,i]))==1) {
sites_total <- sites_total + 1
if
(WestBand[1,i] != Leopard[1,i])
sites_divergent <- sites_divergent + 1
}
}
divergence_rate_WB_L <- sites_divergent / sites_total
print(divergence_rate_WB_L) # 0.0088
#Now repeat for BentToed and Leopard
sites_total <- 0
sites_divergent <- 0
for (i in 1:ncol(BentToed)) {
if
(length(unique(BentToed[,i]))==1 &
length(unique(Leopard[,i]))==1) {
sites_total <- sites_total + 1
if (BentToed[1,i] != Leopard[1,i])
sites_divergent <- sites_divergent + 1
}
}
divergence_rate_BT_L <- sites_divergent / sites_total
print(divergence_rate_BT_L) # 0.0091
#We conclude that WestBanded and BentToed are most closely related, with Leopard as an outlier.
#Leopard is most closely related to the WestBanded to we infer that the Leopard diverged fromt he WestBanded
#at 30mya, then BentToed diverged from WestBanded 15mya.
#estimate mutation rate per site (column) per year (30mya)
#mutation rate is the divergence rate of two species,
#divided by 2 x number of years since divergence
mutation_rate_WB_L_per_my <- divergence_rate_WB_L/(2*30)
print(mutation_rate_WB_L_per_my)
mutation_rate_BT_L_per_my <- divergence_rate_BT_L/(2*30)
print(mutation_rate_BT_L_per_my)
mean_mutation_rate <- (mutation_rate_WB_L_per_my+mutation_rate_BT_L_per_my) /2
print(mean_mutation_rate)
#now estimate divergence time =
# genetic difference of two species / 2 times mutation rate
EDT_WB_L <- divergence_rate_WB_L/(2*mutation_rate_WB_L_per_my)
print(EDT_WB_L)
EDT_WB_BT <- divergence_rate_WB_BT/(2*mean_mutation_rate)
print(EDT_WB_BT) #we can estimate the divergence time for these
#species by using a mean mutation rate
EDT_BT_L <- divergence_rate_WB_L/(2*mutation_rate_BT_L_per_my)
print(EDT_BT_L)
cat("\nThe most likely species tree is L:(W:B).")
source('~/Documents/CMEECourseWork/Week6/Code/Genom1.R')
source('~/Documents/CMEECourseWork/Week6/Code/Genom1.R')
source('~/Documents/CMEECourseWork/Week6/Code/Genom1.R')
#plot
#hist(F)
plot(F, type="h")
source('~/Documents/CMEECourseWork/Week6/Code/Genom1.R')
setwd("~/Documents/CMEECourseWork/Week3/Code")
source("PP_Lattice.R")
source("PP_Lattice.R")
source("MyFirst-ggplot2-Figure.R")
library(ggplot2)
rm(list=ls())
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
pdf("../results/MyFirst-ggplot2-Figure.pdf")
print(qplot(Prey.mass, Predator.mass, data = MyDF, log="xy",
main = "Relation between predator and prey mass",
xlab = "log(Prey mass (g)",
ylab = "log(Predator mass (g)") + theme_bw())
dev.off()
source("MyFirst-ggplot2-Figure.R")
source("Girko.R")
source("MyBars.R")
source("PlotLin.R")
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
install.packages("maps")
require(maps)
gpdd <- load("../Data/GPDDFiltered.RData")
map("world", fill=TRUE, col="white", bg="lightblue", ylim=c(-60, 90), mar=c(0,0,0,0))
points(gpdd$long, gpdd$lat, col="red", pch=1)
gpdd <- load("../Data/GPDDFiltered.RData")
gpdd
load("../Data/GPDDFiltered.RData")
View(gpdd)
map("world", fill=TRUE, col="white", bg="lightblue", ylim=c(-60, 90), mar=c(0,0,0,0))
points(gpdd$long, gpdd$lat, col="red", pch=1)
map("world", fill=TRUE, col="white", bg="lightblue", ylim=c(-60, 90), mar=c(0,0,0,0))
gpdd
map("world", fill=TRUE, col="white", bg="lightblue", ylim=c(-60, 90), mar=c(0,0,0,0))
load("../Data/GPDDFiltered.RData")
map("world", fill=TRUE, col="white", bg="lightblue", ylim=c(-60, 90), mar=c(0,0,0,0))
points(gpdd$long, gpdd$lat, col="red", pch=1)
?maps
source("GDPP_Data.R")
install.packages("maps")
require(maps)
map("world", fill=TRUE, col="white", bg="lightblue", ylim=c(-60, 90), mar=c(0,0,0,0))
points(gpdd$long, gpdd$lat, col="red", pch=1)
# Amy Solman amy.solman19@imperial.ac.uk
# 22nd October 2019
# Mapping.R
rm(list=ls())
graphics.off()
source('~/Documents/CMEECourseWork/Week3/Code/GDPP_Data.R')
source('~/Documents/CMEECourseWork/Week3/Code/GDPP_Data.R')
graphics.off()
plot(1, type="n", xlab="", ylab="", xlim=c(0, 4), ylim=c(0, 4), cex=0.2)
# add length to
sin(-1)
start_position <- c(1,2)
x <- start_position[1]
y <- start_position[2]
atan2(y, x)
# clear any existing graphs and plot your graph within the R window
graphics.off()
chaos_game <- function()  {
# clear any existing graphs and plot your graph within the R window
graphics.off()
plot(1, type="n", xlab="", ylab="", xlim=c(0, 4), ylim=c(0, 4), cex=0.2)
A <- c(0,0)
B <- c(3,4)
C <- c(4,1)
ABC <- rbind(A=A, B=B, C=C)
X <- as.numeric(A)
points(X[1], X[2], cex = 0.2) #plot X
for (i in 1:10000) {
p <- as.numeric(ABC[sample(nrow(ABC), 1), ])
x <- ((x + p[1])/2)
y <- ((y + p[2])/2)
points(x, y, cex = 0.2) #plot X
}
}
chaos_game()
chaos_game <- function()  {
# clear any existing graphs and plot your graph within the R window
graphics.off()
plot(1, type="n", xlab="", ylab="", xlim=c(0, 4), ylim=c(0, 4), cex=0.2)
A <- c(0,0)
B <- c(3,4)
C <- c(4,1)
ABC <- rbind(A=A, B=B, C=C)
X <- as.numeric(A)
points(X[1], X[2], cex = 0.2) #plot X
for (i in 1:10000) {
p <- as.numeric(ABC[sample(nrow(ABC), 1), ])
x <- ((x + p[1])/2)
y <- ((y + p[2])/2)
points(x, y, cex = 0.2) #plot X
}
}
graphics.off()
chaos_game()
Rscript Vectorize1.R
Vectorize1.R
source("Vectorize1.R")
View(M)
# M as an argument
Dimensions <- dim(M) # Dimensions of matrix applied to Dimensions variable
Tot
Tot <- 0 # Numerical value 0 applied to 'Tot'-al
for (i in 1:Dimensions[1]){ # For each element from 1 to the first element in dimensions (1000)
for (j in 1:Dimensions[2]){ # For each element from 1 to the second element in dimensions (1000)
Tot <- Tot + M[i,j] # Tot is assigned the value of Tot plus one element from first dimention
# and one element from second dimension of matrix
}
}
source("Vectorize1.R")
source("Vectorize2.R")
p0=runif(1000,.5,1.5)
p0
rnorm(1, 0, 0.2)
rnorm(1, 0, 0.2)
rnorm(1, 0, 0.2)
rm(list=ls()) # remove all objects from the current workspace
stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100) # assigns function that
# takes the arguments: 'p0' starting population of 1000 randomly generated numbers of a uniform distribution
# 'r' as intrinsic growth rate, 'K' as carrying capacity of environment, 'sigma' as standard deviation,
# and 'numyears' as the number of times the model will be run
{
#initialize
N<-matrix(NA,numyears,length(p0)) # initialize matrix (N) of 100 by 1000 empty element
# so the model should give us a matrix of population numbers by years
N[1,]<-p0 # apply the starting population to the matrix first row, all columns
for (pop in 1:length(p0)) #loop through the populations
# for each element (population number) from 1 to the length of the starting population (1000)
{
for (yr in 2:numyears) #for each pop, loop through the years
# for each year from year two to the total number of years
{
N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma)) # run the stochastic
# (with gauccian fluctuations) Ricker Eqn and applies the results to the 'N' matrix of
# year by population
}
}
return(N)
}
stochrick()
load("../Data/KeyWestAnnualMeanTemperature.Rdata") #load script
head(ats)
plot(ats$Year, ats$Temp) # scatter plot of year (x-axis) and temp(y-axis)
x_t0 <- ats$Temp[-1]
x_t1 <- ats$Temp[-100]
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
correlation_multi <- function(x_t0, x_t1){
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
correlation_loop <- function(x_t0, x_t1){
result <- vector(,1000) #Preallocate expected size
for(i in 1:1000){
result[i] <- correlation_multi()
}
return(result)
}
loop_result <- correlation_loop(x_t0, x_t1)
z <- loop_result > correlation # shows how many times the random sample was greater than our
# original test
x <- length(z[z==TRUE])
y <- length(z[z==FALSE])
p_value = x/y
p_value
x
y
z
loop_result
correlation
ats$Temp[-1]
View(ats)
ats$Temp[-100]
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
plot(x_t0, x_t1) # plot the vectors
p <- plot(x_t0, x_t1) # plot the vectors
p
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
correlation_multi <- function(x_t0, x_t1){
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
correlation_multi()
correlation_multi()
correlation_multi()
correlation_multi()
correlation_multi()
correlation_multi()
correlation_multi()
correlation_loop <- function(x_t0, x_t1){
result <- vector(,1000) #Preallocate expected size
for(i in 1:1000){
result[i] <- correlation_multi()
}
return(result)
}
correlation_loop()
loop_result <- correlation_loop(x_t0, x_t1)
z <- loop_result > correlation # shows how many times the random sample was greater than our
# original test
x <- length(z[z==TRUE])
y <- length(z[z==FALSE])
p_value = x/y
p_value
source("TAutoCorr.R")
# Amy Solman amy.solman19@imperial.ac.uk
# 18th October 2019
# TAutoCorr.R
# Autocorrelation in weather: Are temperatures of one year significantly correlated
#with the next year (successive years), across years in a given location?
# Null hypothesis: There is no significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
# Alternative hypothesis: There is a significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
load("../Data/KeyWestAnnualMeanTemperature.Rdata") #load script
head(ats)
# There are no missing values in the data set so 'na.rm' and 'use' aren't needed
plot(ats$Year, ats$Temp) # scatter plot of year (x-axis) and temp(y-axis)
# Visual assessment shows weak positive correlation between temperature and year
# Get the correlation coefficientthen store it
# Use autocorrelation/lagged correlations
# First create two vecotrs each with length n-1 such that
# the rows correspond to (x[t], x[t-1]) pairs or us
x_t0 <- ats$Temp[-1] # Temps starting from the second
x_t1 <- ats$Temp[-100] #Temps starting from the first
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
# Repeat the calculation 10000 times, randomly permuting the time series, and then recalculating
# correlation coefficient for each randomly permuted year sequence and storing it (use sample function)
# Read the help file for this function and experiment with it
#This function takes the two variables of successive years (x_t0, x_t1)
# as a sample of 99 random temperatures from the list and correlates them
correlation_multi <- function(x_t0, x_t1){
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
# Now I want to repeat this function 10000 times
correlation_loop <- function(x_t0, x_t1){
result <- vector(,1000) #Preallocate expected size
for(i in 1:1000){
result[i] <- correlation_multi()
}
return(result)
}
loop_result <- correlation_loop(x_t0, x_t1)
# Calculate what fraction of the correlation coefficients were greater than that from the first step.
z <- loop_result > correlation # shows how many times the random sample was greater than our
# original test
x <- length(z[z==TRUE])
y <- length(z[z==FALSE])
p_value = x/y
p_value
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida") # scatter plot of year (x-axis) and temp(y-axis)
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)") # scatter plot of year (x-axis) and temp(y-axis)
plot(x_t0, x_t1, main = "Lag-1 correlation of mean temperature per year in Key West, Floria",
xlab = "Year", ylab = "Temperature (°C)") # plot the vectors
plot(x_t0, x_t1, main = "Lag-1 correlation of mean temp per year in Key West, Floria",
xlab = "Year", ylab = "Temperature (°C)") # plot the vectors
plot(x_t0, x_t1, main = "Lag-1 correlation of mean temp per year in Key West, FL",
xlab = "Year", ylab = "Temperature (°C)") # plot the vectors
plot(x_t0, x_t1, main = "Lag-1 corr. of mean temp per year in Key West, FL",
xlab = "Year", ylab = "Temperature (°C)") # plot the vectors
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)")
save("../Results/TAutoPlot1.pdf")#
pdf("../Results/TAutoPlot1.pdf")
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)")
dev.off()
source("TAutoCorr.R")
plot(x_t0, x_t1, main = "Lag-1 corr. of mean temp per year in Key West, FL",
xlab = "Temperature (°C)", ylab = "Temperature (°C)")
correlation_multi <- function(x_t0, x_t1){
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
plot(x_t0, x_t1, main = "Randomly sampled mean temp per year in Key West, FL",
xlab = "Temperature (°C)", ylab = "Temperature (°C)")
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
plot(x_t0, x_t1, main = "Randomly sampled mean temp per year in Key West, FL",
xlab = "Temperature (°C)", ylab = "Temperature (°C)")
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
plot(x_t0, x_t1, main = "Randomly sampled mean temp per year in Key West, FL",
xlab = "Temperature (°C)", ylab = "Temperature (°C)")
source("TAutoCorr.R")
x_t0 <- ats$Temp[-1] # Temps starting from the second
x_t1 <- ats$Temp[-100] #Temps starting from the first
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
pdf("../Results/TAutoPlot2.pdf")
plot(x_t0, x_t1, main = "Lag-1 corr. of mean temp per year in Key West, FL",
xlab = "Temperature (°C)", ylab = "Temperature (°C)")
dev.off()# plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
pdf("../Results/TAutoPlot3.pdf")
plot(x_t0, x_t1, main = "Random pairing of mean yearly temperature in Key West, FL",
xlab = "Temperature (°C)", ylab = "Temperature (°C)")
dev.off()#
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)")
line(ats$Year, ats$Temp)
# There are no missing values in the data set so 'na.rm' and 'use' aren't needed
fit <- lm(Year~Temp, data = ats)
lines(ats$Temp, fitted(fit), col = "c=blue")
lines(ats$Temp, fitted(fit), col = "blue")
fit <- lm(Year~Temp, data = ats)
pdf("../Results/TAutoPlot1.pdf")
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)")
lines(ats$Temp, fitted(fit), col = "blue")
dev.off()
View(fit)
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)", lines = fit)
abline(fit, col = "blue")
fit <- lm(Year~Temp, data = ats)
pdf("../Results/TAutoPlot1.pdf")
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)", lines = fit)
abline(fit, col = "blue")
dev.off()
fit <- lm(Year~Temp, data = ats)
pdf("../Results/TAutoPlot1.pdf")
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)", lines = fit)
abline(fit, col = "blue")
dev.off()
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)", abline(fit, col = "blue"))
fit <- lm(Year~Temp, data = ats)
pdf("../Results/TAutoPlot1.pdf")
plot(ats$Year, ats$Temp, main = "Mean temperature per year in Key West, Florida",
xlab = "Year", ylab = "Temperature (°C)", abline(fit, col = "blue"))
dev.off()
?commandArgs
args = "trees.csv"
MyTrees <- read.csv(args[1], header=TRUE) # read trees.csv to MyTrees data frame
View(MyTrees)
TreeDistance <- MyTrees[[2]] # assign second column of MyTrees data frame to TreeDistance numerical vector
TreeDegrees <- MyTrees[[3]] # assign third column of MyTrees data frame to TreeDegrees numerical vector
TreeHeight <- function(degrees, distance){ # defines the function and the two arguments it will take
radians <- degrees * pi / 180 # applies 'degrees' multiplied by pie divided by 180 to radians
height <- distance * tan(radians)
print(paste(height))
}
Tree.Height <- TreeHeight(TreeDegrees, TreeDistance)
# Add height to MyTrees data frame - WRONG!
MyTrees$"Tree.Height.m" <- Tree.Height
filename <- tools::file_path_sans_ext(args[1])
filename
write.table(paste0(MyTrees, file = "../Results/",filename,"_treeheights.csv", row.names=FALSE, col.names=TRUE))
write.table(MyTrees, file = "../Results/",filename,"_treeheights.csv", row.names=FALSE, col.names=TRUE)
write.table(paste(MyTrees, file = "../Results/",filename,"_treeheights.csv", row.names=FALSE, col.names=TRUE))
?commandArgs
View(ats)
View(MyTrees)
MyTrees <- read.csv("../Data/trees.csv", header=TRUE) # read trees.csv to MyTrees data frame
TreeDistance <- MyTrees[[2]] # assign second column of MyTrees data frame to TreeDistance numerical vector
TreeDegrees <- MyTrees[[3]] # assign third column of MyTrees data frame to TreeDegrees numerical vector
TreeHeight <- function(degrees, distance){ # defines the function and the two arguments it will take
radians <- degrees * pi / 180 # applies 'degrees' multiplied by pie divided by 180 to radians
height <- distance * tan(radians)
print(paste(height))
#return (height)
}
Tree.Height <- TreeHeight(TreeDegrees, TreeDistance)
# Add height to MyTrees data frame - WRONG!
MyTrees$"Tree.Height.m" <- Tree.Height
write.table(MyTrees, file = "../Results/TreeHts.csv", row.names=FALSE, col.names=TRUE)
filename <- tools::file_path_sans_ext(args[1])
filename <- paste0(tools::file_path_sans_ext(args[1]),".csv")
filename <- paste0(tools::file_path_sans_ext(args[1]),"_treeheights.csv")
output_folder <- paste0("../Results/",filename)
