# Amy Solman amy.solman19@imperial.ac.uk
# 22nd October 2019
# PP_Regress.R
# Results of
# an analysis of Linear regression on subsets of the data
#corresponding to available Feeding Type × Predator life Stage
#combination — not a multivariate linear model with these two as separate covariates!
require(ggplot2)
##########OPEN DATASET TO READ - PUT INTO DATAFRAME##########
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
##########CREATES MULTIFACETED PLOT##########
p <- qplot(Prey.mass, Predator.mass, facets = Type.of.feeding.interaction ~., data = MyDF, shape= I(3), log="xy",
xlab = "Prey mass in grams",
ylab = "Predator mass in grams",
colour = Predator.lifestage) +
theme(legend.position="bottom") +
geom_smooth(method = "lm",
fullrange = TRUE)
pdf("../Results/PP_Regress.pdf", 5, 9)
print(p)
dev.off()
My_Data <- MyDF[c("Predator.lifestage", "Type.of.feeding.interaction", "Predator.mass", "Prey.mass")]
head(My_Data)
library(plyr)
# Break up d by state, then fit the specified model to each piece and
# return a list
models <- dlply(My_Data, "Type.of.feeding.interaction", function(df)
lm(Predator.mass ~ Prey.mass, data = df))
# Apply coef to each model and return a data frame
ldply(models, coef)
# Print the summary of each model
l_ply(models, summary, .print = TRUE)
models <- dlply(My_Data, "Type.of.feeding.interaction", "Predator.lifestage", function(df)
lm(Predator.mass ~ Prey.mass, data = df))
models <- dlply(My_Data, "Type.of.feeding.interaction" %>%
"Predator.lifestage", function(df)
lm(Predator.mass ~ Prey.mass, data = df))
View(My_Data)
PiscAdult<-subset(My_Data, My_Data$Type.of.feeding.interaction=="piscivorous" &
My_Data$Predator.lifestage=="adult")
PALinMod <- lm(Predator.mass ~ Prey.mass, data = PiscAdult)
PiscJuv<-subset(My_Data, My_Data$Type.of.feeding.interaction=="piscivorous" &
My_Data$Predator.lifestage=="juvenile")
PJLinMod <- lm(Predator.mass ~ Prey.mass, data = PiscJuv)
PiscLar<-subset(My_Data, My_Data$Type.of.feeding.interaction=="piscivorous" &
My_Data$Predator.lifestage=="larva")
PLLinMod <- lm(Predator.mass ~ Prey.mass, data = PiscLar)
PiscLavJuv<-subset(My_Data, My_Data$Type.of.feeding.interaction=="piscivorous" &
My_Data$Predator.lifestage=="larva/juvenile")
PLJLinMod <- lm(Predator.mass ~ Prey.mass, data = PiscLarJuv)
PiscPost<-subset(My_Data, My_Data$Type.of.feeding.interaction=="piscivorous" &
My_Data$Predator.lifestage=="postlarva")
PPLinMod <- lm(Predator.mass ~ Prey.mass, data = PiscPost)
PiscPostJuv<-subset(My_Data, My_Data$Type.of.feeding.interaction=="piscivorous" &
My_Data$Predator.lifestage=="postlarva/juvenile")
PPJLinMod <- lm(Predator.mass ~ Prey.mass, data = PiscPostJuv)
PALinMod
PJLinMod
PLLinMod
PLJLinMod
PPLinMod
PPJLinMod
PiscLavJuv<-subset(My_Data, My_Data$Type.of.feeding.interaction=="piscivorous" &
My_Data$Predator.lifestage=="larva/juvenile")
PLJLinMod <- lm(Predator.mass ~ Prey.mass, data = PiscLarJuv)
##########OPEN DATASET TO READ - PUT INTO DATAFRAME##########
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
My_Data <- MyDF[c("Predator.lifestage", "Type.of.feeding.interaction", "Predator.mass", "Prey.mass")]
head(My_Data)
library(dplyr)
library(broom)
install.packages("broom")
library(broom)
My_Data %>%
group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
do(tidy(lm(predator.mass ~ Prey.mass, .)))
My_Data %>%
group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
do(tidy(lm(Predator.mass ~ Prey.mass, .)))
write.csv(My_Data, "../Results/PP_Regress_Results.csv") # write it out as a new file
My_Data %>%
group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
do(tidy(lm(Predator.mass ~ Prey.mass, .))) %>%
write.csv(My_Data, "../Results/PP_Regress_Results.csv")
My_Data %>%
group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
do(tidy(lm(Predator.mass ~ Prey.mass, .))) %>%
write.csv("../Results/PP_Regress_Results.csv")
library(data.table)
install.packages("data.table")
library(data.table)
dat <- fread(My_Data)
dat <- fread(EcolArchives-E089-51-D1.csv)
dat <- fread("../Data/EcolArchives-E089-51-D1.csv")
results <- dat[,.(Pvalue=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
beta=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
r2=summary(lm(Predator.mass~Prey.mass))$r.squared),
by=c("Predator.lifestage", "Type.of.fedding.interaction")]
results <- dat[,.(Pvalue=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
beta=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
r2=summary(lm(Predator.mass~Prey.mass))$r.squared),
by=c("Predator.lifestage", "Type.of.feeding.interaction")]
results
write.csv(My_Data, "../Data/MyTrimmedData.csv")
dat <- fread("../Data/MyTrimmedData.csv")
results <- dat[,.(Pvalue=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
beta=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
r2=summary(lm(Predator.mass~Prey.mass))$r.squared),
by=c("Predator.lifestage", "Type.of.feeding.interaction")]
results <- dat[,.(Pvalue=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
beta=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
r2=summary(lm(Predator.mass~Prey.mass))$r.squared),
by=c("Predator.lifestage","Type.of.feeding.interaction")]
rm(list=ls())
##########OPEN DATASET TO READ - PUT INTO DATAFRAME##########
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
My_Data <- MyDF[c("Predator.lifestage", "Type.of.feeding.interaction", "Predator.mass", "Prey.mass")]
library(data.table)
write.csv(My_Data, "../Data/MyTrimmedData.csv")
dat <- fread("../Data/MyTrimmedData.csv")
results <- dat[,.(Pvalue=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
beta=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
r2=summary(lm(Predator.mass~Prey.mass))$r.squared),
by=c("Predator.lifestage","Type.of.feeding.interaction")]
summary.brmsfit(use_cache=FALSE)
summary(object, priors = FALSE, prob = 0.95,
mc_se = FALSE, use_cache=FALSE)
results <- dat[,.(Pvalue=summary(lm(Predator.mass~Prey.mass), priors = FALSE, use_cache = FALSE)$coefficient[2,4],
beta=summary(lm(Predator.mass~Prey.mass), priors = FALSE, use_cache=FALSE))$coefficient[2,4],
r2=summary(lm(Predator.mass~Prey.mass), priors = FALSE, use_cache = FALSE)$r.squared),
by=c("Predator.lifestage", "Type.of.feeding.interaction")]
results <- dat[,.(Pvalue=summary(lm(Predator.mass~Prey.mass)), priors = FALSE, use_cache = FALSE)$coefficient[2,4],
beta=summary(lm(Predator.mass~Prey.mass)), priors = FALSE, use_cache=FALSE$coefficient[2,4],
r2=summary(lm(Predator.mass~Prey.mass)), priors = FALSE, use_cache = FALSE$r.squared),
by=c("Predator.lifestage", "Type.of.feeding.interaction")]
results <- dat[,.(Pvalue=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
beta=summary(lm(Predator.mass~Prey.mass))$coefficient[2,4],
r2=summary(lm(Predator.mass~Prey.mass))$r.squared),
by=c("Predator.lifestage","Type.of.feeding.interaction")]
source apply1.R
source("apply1.R")
source("DataWrang.R")
source("apply2.R")
source("basic_io.R")
source("boilerplate.R")
source("break.R")
source("browse.R")
source("countrol_flow.R")
source("control_flow.R")
source("DataWrang.R")
############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F, stringsAsFactors = F))
# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)
############# Inspect the dataset ###############
head(MyData) # shows top six data entries for each column
dim(MyData) # shows numnber of rows and columns
str(MyData) # shows structure of our data frame
fix(MyData) #you can also do this
source("DataWrang.R")
source("DataWrang.R")
source("DataWrangTidy.R")
source("DataWrangTidy.R")
source("Girko.R")
source("Girko.R")
source("Girko.R")
source("Mapping.R")
source("MyBars.R")
source("next.R")
source("PlotLin.R")
source("PP_Lattice.R")
source("PP_Regress.R")
source("PP_Regress.R")
install.packages("broom")
source("PP_Regress.R")
source("preallocate.R")
source("preallocate.R")
source("preallocate.R")
source("preallocate.R")
source("preallocate.R")
source("preallocate.R")
source("Ricker.R")
source("sample.R")
source("TAutoCorr.R")
# Null hypothesis: There is no significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
# Alternative hypothesis: There is a significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
rm(list=ls())
load("../Data/KeyWestAnnualMeanTemperature.Rdata")
head(ats)
plot(ats$Year, ats$Temp) # scatter plot of year (x-axis) and temp(y-axis)
x_t0 <- ats$Temp[-1]
x_t1 <- ats$Temp[-100]
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
correlation_multi <- function(x_t0, x_t1){ # assign function that will take the popn and sample size
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
correlation_multi <- function(x_t0, x_t1){ # assign function that will take the popn and sample size
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
}
return(cor(x_t0, x_t1))
correlation_loop() <- function(x_t0, x_t1){ # assign function that will take popn, sample size,
# number of times to rerun experiment
result <- vector(, 10000)
for (i in 1:10000){ # for each element from 1 to the re-run number
result[i] <- correlation_multi() # run myexperiment on popn
# concatenate with result1 empty vector
}
return(result)
}
correlation_loop <- function(x_t0, x_t1){ # assign function that will take popn, sample size,
# number of times to rerun experiment
result <- vector(, 10000)
for (i in 1:10000){ # for each element from 1 to the re-run number
result[i] <- correlation_multi() # run myexperiment on popn
# concatenate with result1 empty vector
}
return(result)
}
# number of times to rerun experiment
result <- vector(, 10000)
for (i in 1:10000){ # for each element from 1 to the re-run number
result[i] <- correlation_multi() # run myexperiment on popn
# concatenate with result1 empty vector
}
# Amy Solman amy.solman19@imperial.ac.uk
# 18th October 2019
# TAutoCorr.R
# Null hypothesis: There is no significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
# Alternative hypothesis: There is a significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
rm(list=ls())
load("../Data/KeyWestAnnualMeanTemperature.Rdata")
head(ats)
# There are no missing values in the data set so 'na.rm' and 'use' aren't needed
plot(ats$Year, ats$Temp) # scatter plot of year (x-axis) and temp(y-axis)
# Visual assessment shows weak positive correlation between temperature and year
# Get the correlation coefficientthen store it
# Use autocorrelation/lagged correlations
# First create two vecotrs each with length n-1 such that
# the rows correspond to (x[t], x[t-1]) pairs or us
x_t0 <- ats$Temp[-1]
x_t1 <- ats$Temp[-100]
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
# Repeat the calculation 10000 times, randomly permuting the time series, and then recalculating
# correlation coefficient for each randomly permuted year sequence and storing it (use sample function)
# Read the help file for this function and experiment with it
correlation_multi <- function(x_t0, x_t1){ # assign function that will take the popn and sample size
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
correlation_loop <- function(x_t0, x_t1){ # assign function that will take popn, sample size,
# number of times to rerun experiment
result <- vector(, 10000)
for (i in 1:10000){ # for each element from 1 to the re-run number
result[i] <- correlation_multi() # run myexperiment on popn
# concatenate with result1 empty vector
}
return(result)
}
repeat_results<- correlation_loop
repeat_results
# Calculate what fraction of the correlation coefficients were greater than that from the first step.
z <- repeat_results > correlation # shows how many times the random sample was greater than our
# original test
x <- length(z[z==TRUE])
y <- length(z[z==FALSE])
p_value = x/y
p_value
rm(list=ls())
# Amy Solman amy.solman19@imperial.ac.uk
# 18th October 2019
# TAutoCorr.R
# Null hypothesis: There is no significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
# Alternative hypothesis: There is a significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
load("../Data/KeyWestAnnualMeanTemperature.Rdata")
head(ats)
# There are no missing values in the data set so 'na.rm' and 'use' aren't needed
plot(ats$Year, ats$Temp) # scatter plot of year (x-axis) and temp(y-axis)
# Visual assessment shows weak positive correlation between temperature and year
# Get the correlation coefficientthen store it
# Use autocorrelation/lagged correlations
# First create two vecotrs each with length n-1 such that
# the rows correspond to (x[t], x[t-1]) pairs or us
x_t0 <- ats$Temp[-1]
x_t1 <- ats$Temp[-100]
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
# Repeat the calculation 10000 times, randomly permuting the time series, and then recalculating
# correlation coefficient for each randomly permuted year sequence and storing it (use sample function)
# Read the help file for this function and experiment with it
correlation_multi <- function(x_t0, x_t1){ # assign function that will take the popn and sample size
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
correlation_loop() <- function(x_t0, x_t1){ # assign function that will take popn, sample size,
# number of times to rerun experiment
result <- vector(, 10000)
for (i in 1:10000){ # for each element from 1 to the re-run number
result[i] <- correlation_multi() # run myexperiment on popn
# concatenate with result1 empty vector
}
return(result)
}
repeat_results<- correlation_loop()
repeat_results
# Calculate what fraction of the correlation coefficients were greater than that from the first step.
z <- repeat_results > correlation # shows how many times the random sample was greater than our
# original test
x <- length(z[z==TRUE])
y <- length(z[z==FALSE])
p_value = x/y
p_value
load("../Data/KeyWestAnnualMeanTemperature.Rdata") #load script
head(ats)
plot(ats$Year, ats$Temp) # scatter plot of year (x-axis) and temp(y-axis)
# Get the correlation coefficientthen store it
# Use autocorrelation/lagged correlations
# First create two vecotrs each with length n-1 such that
# the rows correspond to (x[t], x[t-1]) pairs or us
x_t0 <- ats$Temp[-1]
x_t1 <- ats$Temp[-100]
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
View(ats)
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
correlation_multi <- function(x_t0, x_t1){ # assign function that will take the popn and sample size
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
rm(list=ls())
# Amy Solman amy.solman19@imperial.ac.uk
# 18th October 2019
# TAutoCorr.R
# Null hypothesis: There is no significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
# Alternative hypothesis: There is a significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
load("../Data/KeyWestAnnualMeanTemperature.Rdata") #load script
head(ats)
# There are no missing values in the data set so 'na.rm' and 'use' aren't needed
plot(ats$Year, ats$Temp) # scatter plot of year (x-axis) and temp(y-axis)
# Visual assessment shows weak positive correlation between temperature and year
# Get the correlation coefficientthen store it
# Use autocorrelation/lagged correlations
# First create two vecotrs each with length n-1 such that
# the rows correspond to (x[t], x[t-1]) pairs or us
x_t0 <- ats$Temp[-1]
x_t1 <- ats$Temp[-100]
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
# Repeat the calculation 10000 times, randomly permuting the time series, and then recalculating
# correlation coefficient for each randomly permuted year sequence and storing it (use sample function)
# Read the help file for this function and experiment with it
#This function takes the two variables of successive years (x_t0, x_t1)
# as a sample of 99 random temperatures from the list and correlates them
correlation_multi <- function(x_t0, x_t1){
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
correlation_lopp <- function(x_t0, x_t1){
result <- vector(,1000) #Preallocate expected size
for(i in 1:1000){
result[i] <- correlation_multi()
}
return(result)
}
repeat_results<- correlation_loop
correlation_loop <- function(x_t0, x_t1){
result <- vector(,1000) #Preallocate expected size
for(i in 1:1000){
result[i] <- correlation_multi()
}
return(result)
}
repeat_results<- correlation_loop
repeat_results
class(repeat_results)
# Amy Solman amy.solman19@imperial.ac.uk
# 18th October 2019
# TAutoCorr.R
# Null hypothesis: There is no significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
# Alternative hypothesis: There is a significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
load("../Data/KeyWestAnnualMeanTemperature.Rdata") #load script
head(ats)
# There are no missing values in the data set so 'na.rm' and 'use' aren't needed
plot(ats$Year, ats$Temp) # scatter plot of year (x-axis) and temp(y-axis)
# Visual assessment shows weak positive correlation between temperature and year
# Get the correlation coefficientthen store it
# Use autocorrelation/lagged correlations
# First create two vecotrs each with length n-1 such that
# the rows correspond to (x[t], x[t-1]) pairs or us
x_t0 <- ats$Temp[-1]
x_t1 <- ats$Temp[-100]
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
# Repeat the calculation 10000 times, randomly permuting the time series, and then recalculating
# correlation coefficient for each randomly permuted year sequence and storing it (use sample function)
# Read the help file for this function and experiment with it
#This function takes the two variables of successive years (x_t0, x_t1)
# as a sample of 99 random temperatures from the list and correlates them
correlation_multi <- function(x_t0, x_t1){
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
# Now I want to repeat this function 10000 times
correlation_loop <- function(x_t0, x_t1){
result <- vector(,1000) #Preallocate expected size
for(i in 1:1000){
result[i] <- correlation_multi()
}
return(result)
}
z <- result > correlation # shows how many times the random sample was greater than our
# original test
x <- length(z[z==TRUE])
y <- length(z[z==FALSE])
p_value = x/y
p_value
correlation_loop(x_t0, x_t1)
# Amy Solman amy.solman19@imperial.ac.uk
# 18th October 2019
# TAutoCorr.R
# Null hypothesis: There is no significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
# Alternative hypothesis: There is a significant correlation between the temperatures of
# one year with the next year in a given location (Key West)
load("../Data/KeyWestAnnualMeanTemperature.Rdata") #load script
head(ats)
# There are no missing values in the data set so 'na.rm' and 'use' aren't needed
plot(ats$Year, ats$Temp) # scatter plot of year (x-axis) and temp(y-axis)
# Visual assessment shows weak positive correlation between temperature and year
# Get the correlation coefficientthen store it
# Use autocorrelation/lagged correlations
# First create two vecotrs each with length n-1 such that
# the rows correspond to (x[t], x[t-1]) pairs or us
x_t0 <- ats$Temp[-1]
x_t1 <- ats$Temp[-100]
head(cbind(x_t0, x_t1)) # Confirm that these vectors are the right pairs
plot(x_t0, x_t1) # plot the vectors
correlation <- cor(x_t0, x_t1) # Compute the correlation coefficient
# and store it
correlation
# Repeat the calculation 10000 times, randomly permuting the time series, and then recalculating
# correlation coefficient for each randomly permuted year sequence and storing it (use sample function)
# Read the help file for this function and experiment with it
#This function takes the two variables of successive years (x_t0, x_t1)
# as a sample of 99 random temperatures from the list and correlates them
correlation_multi <- function(x_t0, x_t1){
x_t0 <- sample(ats$Temp, 99, replace = FALSE)
x_t1 <- sample(ats$Temp, 99, replace = FALSE)
return(cor(x_t0, x_t1))
}
# Now I want to repeat this function 10000 times
correlation_loop <- function(x_t0, x_t1){
result <- vector(,1000) #Preallocate expected size
for(i in 1:1000){
result[i] <- correlation_multi()
}
return(result)
}
loop_result <- correlation_loop(x_t0, x_t1)
z <- loop_result > correlation # shows how many times the random sample was greater than our
# original test
x <- length(z[z==TRUE])
y <- length(z[z==FALSE])
p_value = x/y
p_value
rm(list=ls())
source("TAutoCorr.R")
source("TreeHeight.R")
source("TreeHeight.R")
source("try.R")
source("Vectorize1.R")
source("Vectorize2.R")
